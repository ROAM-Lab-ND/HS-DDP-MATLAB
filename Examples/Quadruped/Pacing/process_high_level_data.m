function [hybridRef, ctactSeq, dt] = process_high_level_data()
% This function parse the high-level planned trajectory to construct a
% multi-phase trajecotry optimization problem to be solved using HSDDP. The
% high-level plan is generated by simulating a RL policy. The RL policy
% used here is from Google's motion imitation work. Details of this work
% could be found at https://github.com/heli-sudoo/motion_imitation

% hybridRef: 1xn cell array of reference trajectory (in structure TrajReference)
% ctactSeq: 1x(n+1) cell array of contact status, each is a 1x4 vector
% dt: integration time step

opts = fixedWidthImportOptions('VariableWidths', 10, 'VariableTypes', 'double');
time_array = readmatrix('timestep.txt', opts);
ctact_array = readmatrix('contact.txt'); % contact status of each foot at every time step
torque_array = readmatrix('torque.txt');
q_array = readmatrix('generalized_joint.txt');
qd_array = readmatrix('generalized_vel.txt');
state_array = [q_array, qd_array];

% Count the number of phases and separate the phases
len_horizon = size(ctact_array, 1);
dt = time_array(2) - time_array(1);
ctactSeq = cell(1, 100);
jstart = zeros(1, 100);
jend = zeros(1, 100);
n = 1;
i = 1;
for k = 1:min(len_horizon,200)
    if isempty(ctactSeq{1})
        % If ctactSeq is empty, add the first element of ctact_array
        ctactSeq{i} = ctact_array(1, :);
        jstart(i) = 1;
        jend(i) = 1;
    else
        if ~isequal(ctact_array(k, :), ctactSeq{i})
            ctactSeq{i+1} = ctact_array(k, :);
            jstart(i+1) = jend(i);
            i = i + 1;
        end
        jend(i) = k;
    end
    n = i;
end
ctactSeq(n+1:end) = [];
jstart(n+1:end) = [];
jend(n+1:end) = [];

hybridRef = cell(1, n-1);
for i = 1:n-1
    r = TrajReference(36, 12, 12, jend(i)-jstart(i)+1);
    r.xd = state_array(jstart(i):jend(i), :)';
    r.ud = torque_array(jstart(i):jend(i), :)';
    hybridRef{i} = r;
end
plot_phase_duration(hybridRef);
[hybridRef, ctactSeq] = filter_short_contact(hybridRef, ctactSeq);
plot_phase_duration(hybridRef);
end

function [hybridT_new, ctactSeq_new] = filter_short_contact(hybridT, ctactSeq)
% Any phase whole duration is less then thresh is considered as an
% incorrect contact dectection is integrated to the previous one phase
thresh = 4;
n = length(hybridT);
hybridT_new = hybridT(1);
ctactSeq_new = ctactSeq(1);
inew = 1;
for i = 2:n
    if hybridT{i}.len < thresh
        hybridT_new{inew}.append(hybridT{i});
    else
        hybridT_new{end+1} = hybridT{i};
        ctactSeq_new{end+1} = ctactSeq{i};
        inew = inew + 1;
    end
end
end

function plot_phase_duration(hybridT)
n = length(hybridT);
len_horizons = zeros(1, n);
for i = 1:length(hybridT)
    len_horizons(i) = hybridT{i}.len;
end
figure
plot(1:n, len_horizons);
xlabel('phase index');
ylabel('phase horizon');
end