function [hybridRef, ctactSeq, dt] = process_high_level_data()
% This function parse the high-level planned trajectory to construct a
% multi-phase trajecotry optimization problem to be solved using HSDDP. The
% high-level plan is generated by simulating a RL policy. The RL policy
% used here is from Google's motion imitation work. Details of this work
% could be found at https://github.com/heli-sudoo/motion_imitation

% hybridRef: 1xn cell array of reference trajectory (in structure TrajReference)
% ctactSeq: 1x(n+1) cell array of contact status, each is a 1x4 vector
% dt: integration time step

opts = fixedWidthImportOptions('VariableWidths', 10, 'VariableTypes', 'double');
time_array = readmatrix('timestep.txt', opts);
ctact_array = readmatrix('contact.txt'); % contact status of each foot at every time step
torque_array = readmatrix('torque.txt');
q_array = readmatrix('generalized_joint.txt');
qd_array = readmatrix('generalized_vel.txt');
state_array = [q_array, qd_array];

%% Separate the phases based on contact status
len_horizon = size(ctact_array, 1);
dt = time_array(2) - time_array(1);
ctactSeq = cell(1, 100);
jstart = zeros(1, 100);
jend = zeros(1, 100);
n = 1;
i = 1;
for k = 1:min(len_horizon,200)
    if isempty(ctactSeq{1})
        % If ctactSeq is empty, add the first element of ctact_array
        ctactSeq{i} = ctact_array(1, :);
        jstart(i) = 1;
        jend(i) = 1;
    else
        if ~isequal(ctact_array(k, :), ctactSeq{i})
            ctactSeq{i+1} = ctact_array(k, :);
            jstart(i+1) = jend(i);
            i = i + 1;
        end
        jend(i) = k;
    end
    n = i;
end
ctactSeq(n+1:end) = [];
jstart(n+1:end) = [];
jend(n+1:end) = [];

hybridRef = cell(1, n-1);
for i = 1:n-1
    len_horizon = jend(i)-jstart(i)+1;
    r = TrajReference(36, 12, 12, len_horizon);
    r.xd = mat2cell(state_array(jstart(i):jend(i), :)', 36, ones(1,len_horizon));
    r.ud = mat2cell(torque_array(jstart(i):jend(i), :)', 12, ones(1,len_horizon));
    hybridRef{i} = r;
end

% Append the end of last phase to the begining of current phase
for i = 2:length(hybridRef)
    hybridRef{i}.xd = [hybridRef{i-1}.xd{end}, hybridRef{i}.xd];
    hybridRef{i}.ud = [hybridRef{i-1}.ud{end}, hybridRef{i}.ud];
    hybridRef{i}.yd = [hybridRef{i-1}.yd{end}, hybridRef{i}.yd];
    hybridRef{i}.len = hybridRef{i}.len + 1;
end

%% Filter out short contact
[hybridRef, ctactSeq] = filter_short_contact(hybridRef, ctactSeq);
% plot_phase_duration(hybridRef);

%% Flip hip and knee rotations
for i=1:length(hybridRef)
    hybridRef{i} = flip_signs_for_MC(hybridRef{i});
end

%% Refine the trajectory such that time step is 0.001 s
% hybridRef = refine_trajectory(hybridRef);
% dt = 0.001;

end

function [hybridT_new, ctactSeq_new] = filter_short_contact(hybridT, ctactSeq)
% Any phase whole duration is less then thresh is considered as an
% incorrect contact dectection is integrated to the previous one phase
thresh = 4;
n = length(hybridT);
hybridT_new = hybridT(1);
ctactSeq_new = ctactSeq(1);
inew = 1;
for i = 2:n
    if hybridT{i}.len < thresh
        hybridT_new{inew}.append(hybridT{i});
    else
        hybridT_new{end+1} = hybridT{i};
        ctactSeq_new{end+1} = ctactSeq{i};
        inew = inew + 1;
    end
end
end

function plot_phase_duration(hybridT)
n = length(hybridT);
len_horizons = zeros(1, n);
for i = 1:length(hybridT)
    len_horizons(i) = hybridT{i}.len;
end
figure
plot(1:n, len_horizons);
xlabel('phase index');
ylabel('phase horizon');
end

function hybrid_fine = refine_trajectory(hybridR)
% Refine the trajectory so that the time step is 0.001 s
hybrid_fine = cell(1, length(hybridR));
for i = 1:length(hybrid_fine)
    duration = (hybridR{i}.len-1) * 0.033;
    len_horizon = int16(duration/0.001) + 1;
    hybrid_fine{i} = TrajReference(36, 12, 12, len_horizon);
    k = 1;
    for j = 1:hybridR{i}.len-1
        hybrid_fine{i}.ud(k:k + 32) =  repmat({hybridR{i}.ud{j}/33},1,33);
        x_seg = interpolate_vector(hybridR{i}.xd{j}, hybridR{i}.xd{j+1}, 34);
        hybrid_fine{i}.xd(k:k+33) = mat2cell(x_seg, 36, ones(1,34));
        k = k + 33;
    end     
end
end

function X = interpolate_vector(x1, x2, n)
m = length(x1(:));
X = zeros(m, n);
for i = 1:m
    X(i, :) = linspace(x1(i), x2(i), n);
end
end